#!/usr/bin/env bash

# This script is designed to help someone bootstrap terraform and requires the
# user already has AWS credentials and Terraform installed

# NOTE: we use the aws command line tool to verify you have access configured
check_aws_prerequisites() {
  aws sts get-caller-identity 2>&1 >/dev/null
  if [[ $? -ne 0 ]]; then
    echo "You must configure your local 'aws' client before using this tool"
    exit 1
  fi

  local __tfver=$(terraform version | sed 's/^.* v//' 2>/dev/null)
  if [[ $? -eq 0 ]]; then
    local __tmp=( ${__tfver//./ } )
    if [[ ${__tmp[0]} -eq 1 ]]; then
      if [[ ${__tmp[1]} -eq 0 ]] && [[ ${__tmp[2]} -ge 3 ]]; then
        :
      elif [[ ${__tmp[1]} -ge 1 ]]; then
        :
      else
        echo "You must install Terraform 1.0.3 or higher"
        exit 1
      fi
    else
      echo "You must install Terraform 1.0.3 or higher"
      exit 1
    fi
  else
    echo "You must install Terraform 1.0.3 or higher"
    exit 1
  fi
  return 0
}

# Check for top-level config.yaml to override defaults
if test -e $(cd $(dirname ${BASH_SOURCE[0]})/..; pwd -P)/config.yaml; then
  __cloud=$(grep ^cloud_provider: $(cd $(dirname ${BASH_SOURCE[0]})/..; pwd -P)/config.yaml | awk '{print $2}')
else
  __cloud=k3d
fi

echo bootstrapping terraform for ${__cloud}
__root=$(cd $(dirname ${BASH_SOURCE[0]})/..; pwd -P)

if [[ ${__cloud} == aws ]]; then
  check_aws_prerequisites

  set -e
  cd ${__root}/bootstrap
  terraform init
  terraform validate
  set +e
  terraform plan -detailed-exitcode -input=false
  __ret=$?
  case ${__ret} in
    2) terraform apply -auto-approve ;;
    0) echo terraform apply skipped with no changes ;;
    *) echo terraform plan result ${__ret} && exit ${__ret} ;;
  esac
  __ret=$?
  case ${__ret} in
    0) echo terraform apply successful ;;
    *) echo terraform apply result ${__ret} && exit ${__ret} ;;
  esac

  set -e
  __bucket=$(terraform output -raw terraform_state_bucket)
  __region=$(terraform output -raw region)
  if [[ ${__bucket} =~ terraform-state ]]; then
    echo Terraform state bucket: ${__bucket}
  else
    echo Cloud not detect state bucket && exit 1
  fi
  if [[ ${__region} == REGION ]]; then
    echo Region is not set && exit 1
  else
    echo Terraform state bucket region: ${__region}
  fi

  set +e
  # configure bootstrap backend
  __configure_bootstrap_backend=false
  if [[ ! -e backend.tf ]]; then
    __configure_bootstrap_backend=true
  elif [[ $(grep -o BUCKET_NAME backend.tf 2>/dev/null) == BUCKET_NAME ]]; then
    __configure_bootstrap_backend=true
  elif [[ $(grep -o REGION backend.tf 2>/dev/null) == REGION ]]; then
    __configure_bootstrap_backend=true
  fi
  set -e
  if [[ ${__configure_bootstrap_backend} == true ]]; then
    echo configuring bootstrap backend
    sed -e "s#BUCKET_NAME#${__bucket}#" \
        -e "s#REGION#${__region}#" \
        backend-aws.tf.example > backend.tf
    terraform init -migrate-state -force-copy
  fi

  echo starting stage0 on ${__cloud}
  cd ${__root}/stage0/aws-terraform
  if ! test -e backend.tf; then
    sed -e "s#BUCKET_NAME#${__bucket}#" \
        -e "s#REGION#${__region}#" \
        backend.tf.example > backend.tf
  fi

  terraform init
  terraform validate
  set +e
  terraform plan -detailed-exitcode -input=false
  __ret=$?
  case ${__ret} in
    2) terraform apply -auto-approve ;;
    0) echo terraform apply skipped with no changes ;;
    *) echo terraform plan result ${__ret} && exit ${__ret} ;;
  esac
  __ret=$?
  case ${__ret} in
    0) echo terraform apply successful ;;
    *) echo terraform apply result ${__ret} && exit ${__ret} ;;
  esac

else # k3d

  cd ${__root}/bootstrap
  if test -e ${__root}/config.yaml; then
    __name=$(grep ^cluster_name: ${__root}/config.yaml | awk '{print $2}')
  else
    __name=dmtr-cluster
  fi
  echo k3d cluster create --k3s-arg "--disable=traefik@server:0" --image rancher/k3s:v1.25.6-k3s1 --port 80:80@server:0:direct --no-lb ${__name}
  sleep 1
  echo waiting for local-path-provisioner
  while true; do
    kubectl get -n kube-system deployment/local-path-provisioner configmap/local-path-config
    __ret=$?
    if [[ ${__ret} -eq 0 ]]; then
      break
    fi
  done
  echo patching
  set -e
  # Patch local-path-provisioner to enable RWX PVs
  kubectl patch -n kube-system configmap/local-path-config --patch-file patches/local-path-provisioner-configmap.yaml
  kubectl patch -n kube-system deployment/local-path-provisioner --patch-file patches/local-path-provisioner-deployment.yaml
  # Patches local-path storageclass to not default
  kubectl patch storageclass/local-path --patch-file patches/local-path-provisioner-storageclass.yaml

fi
